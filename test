package com.schwab.express.common.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import schwab.endpoint.security.svcreg.EnterprisePolicyRepository;

@Configuration
public class SecurityConfig {

    @Bean
    public EnterprisePolicyRepository enterprisePolicyRepository(@Value("${schwab.policy.repository.url}") String policyRepositoryUrl) {
        return new EnterprisePolicyRepository.Builder()
                .url(policyRepositoryUrl)
                .build();
    }
}








package com.schwab.express.common.gateway.security;

import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;
import schwab.endpoint.security.BackendUnavailableException;
import schwab.endpoint.security.KeyService;
import schwab.endpoint.security.SecurityToken;
import schwab.endpoint.security.UnauthorizedMessageException;
import schwab.endpoint.security.svcreg.EnterprisePolicyRepository;
import schwab.endpoint.security.svcreg.ServiceNotFoundException;
import schwab.endpoint.security.svcreg.ConstraintPolicy;

import java.util.HashMap;
import java.util.Map;

@Component
public class TransitionPolicyBasedMessageAuthenticator {

    @Value("${tokenClientId:Customer Account Technology}")
    String tokenClientId;

    private final EnterprisePolicyRepository policyRepository;
    private final KeyService keyService;

    public TransitionPolicyBasedMessageAuthenticator(EnterprisePolicyRepository policyRepository, @Qualifier("keyService") KeyService keyService) {
        this.policyRepository = policyRepository;
        this.keyService = keyService;
    }

    public SecurityToken authenticate(String serviceKey, String operation, String authorization, long clockSkewSeconds)
            throws UnauthorizedMessageException, BackendUnavailableException {
        try {
            Map<String, String> headers = new HashMap<>();
            headers.put("Authorization", authorization);

            SecurityToken token = policyRepository.forService(serviceKey)
                    .appliesTo(new ConstraintPolicy.Filter(serviceKey, operation))
                    .withAuthorization(headers, "POST", "/")
                    .enforce(keyService);

            checkPolicy(serviceKey, operation, token);
            return token;

        } catch (ServiceNotFoundException e) {
            throw new UnauthorizedMessageException("Service not found: " + serviceKey);
        }
    }

    protected void checkPolicy(String serviceKey, String operation, SecurityToken token)
            throws UnauthorizedMessageException {

        String clientId = token.getClientId();

        if (!clientId.equalsIgnoreCase(tokenClientId)) {
            throw new UnauthorizedMessageException("Unauthorized Token Passed");
        }
    }
}











package com.schwab.express.common.config;

import com.schwab.express.common.gateway.security.TransitionPolicyBasedMessageAuthenticator;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.messaging.rsocket.RSocketStrategies;
import org.springframework.messaging.rsocket.annotation.support.RSocketMessageHandler;
import org.springframework.security.config.annotation.method.configuration.EnableReactiveMethodSecurity;
import org.springframework.security.config.annotation.rsocket.EnableRSocketSecurity;
import org.springframework.security.config.annotation.rsocket.RSocketSecurity;
import org.springframework.security.messaging.handler.invocation.reactive.AuthenticationPrincipalArgumentResolver;
import org.springframework.security.oauth2.jwt.Jwt;
import org.springframework.security.oauth2.jwt.JwtException;
import org.springframework.security.oauth2.jwt.ReactiveJwtDecoder;
import org.springframework.security.oauth2.server.resource.authentication.JwtAuthenticationConverter;
import org.springframework.security.oauth2.server.resource.authentication.JwtReactiveAuthenticationManager;
import org.springframework.security.oauth2.server.resource.authentication.ReactiveJwtAuthenticationConverterAdapter;
import org.springframework.security.rsocket.core.PayloadSocketAcceptorInterceptor;
import reactor.core.publisher.Mono;

import java.time.Instant;
import java.time.temporal.ChronoUnit;
import java.util.Collections;
import java.util.Map;

@Configuration
@EnableRSocketSecurity
@EnableReactiveMethodSecurity
public class RSocketSecurityConfig {

    @Value("${schwab.rrbus.service.key}")
    String serviceKey;

    @Autowired
    private TransitionPolicyBasedMessageAuthenticator transitionPolicyBasedMessageAuthenticator;

    @Bean
    RSocketMessageHandler messageHandler(RSocketStrategies strategies) {
        RSocketMessageHandler handler = new RSocketMessageHandler();
        handler
                .getArgumentResolverConfigurer()
                .addCustomResolver(new AuthenticationPrincipalArgumentResolver());
        handler.setRSocketStrategies(strategies);
        return handler;
    }

    @Bean
    public PayloadSocketAcceptorInterceptor rsocketInterceptor(RSocketSecurity rsocket) {
        rsocket
                .authorizePayload(authorize -> authorize.anyExchange().authenticated())
                .jwt(
                        jwtSpec -> jwtSpec.authenticationManager(jwtReactiveAuthenticationManager()));

        return rsocket.build();
    }

    @Bean
    public JwtReactiveAuthenticationManager jwtReactiveAuthenticationManager() {
        JwtReactiveAuthenticationManager jwtReactiveAuthenticationManager =
                new JwtReactiveAuthenticationManager(defaultReactiveJwtDecoder());

        JwtAuthenticationConverter authenticationConverter = new JwtAuthenticationConverter();
        jwtReactiveAuthenticationManager.setJwtAuthenticationConverter(
                new ReactiveJwtAuthenticationConverterAdapter(authenticationConverter));
        return jwtReactiveAuthenticationManager;
    }

    @Bean
    public ReactiveJwtDecoder defaultReactiveJwtDecoder() {
        return new SchwabReactiveJwtDecoder();
    }

    public class SchwabReactiveJwtDecoder implements ReactiveJwtDecoder {

        @Override
        public Mono<Jwt> decode(String token) {
            try {

                Map<String, Object> headers = Collections.singletonMap("Content-Type", "application/json");

                Map<String, Object> map = Collections.singletonMap("Content-Type", "application/json");

                String auth = "Bearer " + token;

                transitionPolicyBasedMessageAuthenticator.authenticate(serviceKey, "POST", auth, 0L);

                return Mono.just(
                        new Jwt(token, Instant.now(), Instant.now().plus(10, ChronoUnit.DAYS), headers, map));

            } catch (Exception e) {
                throw new JwtException("Cannot Authenticate Token " + e.getMessage(), e);
            }
        }
    }
}



