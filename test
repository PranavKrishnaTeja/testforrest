package com.schwab.cdt.spos.source.job.step.writer;

import com.datastax.oss.driver.api.core.CqlSession;
import com.datastax.oss.driver.api.core.cql.AsyncResultSet;
import com.datastax.oss.driver.api.core.cql.BoundStatement;
import com.datastax.oss.driver.api.core.cql.PreparedStatement;
import com.datastax.oss.driver.api.core.cql.SimpleStatement;
import com.schwab.cdt.spos.source.config.cassandra.CassandraConfig;
import com.schwab.cdt.spos.source.job.aggregate.AggregateFactory;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.ArgumentCaptor;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.springframework.batch.item.Chunk;

import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.CompletionStage;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.*;

class CassandraItemWriterTest {

    @Mock
    private CqlSession session;

    @Mock
    private CassandraConfig cassandraConfig;

    @Mock
    private PreparedStatement preparedStatement;

    @Mock
    private BoundStatement boundStatement;

    @Mock
    private CompletionStage<AsyncResultSet> completionStage;

    @InjectMocks
    private CassandraItemWriter cassandraItemWriter;

    // More detailed mocking for Aggregate, Table, Columns, and Metadata
    @Mock
    private AggregateFactory.Aggregate aggregate;

    @Mock
    private AggregateFactory.Table table;

    @Mock
    private List<AggregateFactory.Columns> columns;

    @Mock
    private AggregateFactory.Columns column;

    @Mock
    private AggregateFactory.Metadata metadata;

    @BeforeEach
    void setUp() {
        MockitoAnnotations.openMocks(this);

        // Mocking the session and statement behaviors
        when(session.prepare(any(SimpleStatement.class))).thenReturn(preparedStatement);
        when(session.prepare(anyString())).thenReturn(preparedStatement);

        when(preparedStatement.bind()).thenReturn(boundStatement);
        when(session.executeAsync(any(BoundStatement.class))).thenReturn(completionStage);

        // Mocking aggregate and its methods
        when(aggregate.table()).thenReturn(table);
        when(table.columns()).thenReturn(columns);
        when(columns.size()).thenReturn(1); // Assuming at least one column
        when(columns.get(0)).thenReturn(column);
        when(column.name()).thenReturn("column");
        when(column.metadata()).thenReturn(metadata);
        when(metadata.value()).thenReturn(new BigDecimal("100.00"));
    }

    @Test
    void testWrite() {
        // Arrange
        List<AggregateFactory.Aggregate> aggregates = new ArrayList<>();
        aggregates.add(aggregate);

        // Act
        cassandraItemWriter.write(new Chunk<>(aggregates));

        // Assert
        ArgumentCaptor<BoundStatement> boundStatementCaptor = ArgumentCaptor.forClass(BoundStatement.class);
        verify(session).executeAsync(boundStatementCaptor.capture());

        BoundStatement capturedStatement = boundStatementCaptor.getValue();
        assertEquals(new BigDecimal("100.00"), capturedStatement.getBigDecimal("column"));
    }
}
