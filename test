public boolean shouldSkipForDelimitedLine(String schemaName, String[] tokens) {
    SchemaMapping schemaMapping = schemaConfigProperties.getMappingDetails().get(schemaName);
    if (schemaMapping == null || schemaMapping.getSkipPolicy() == null ||
            CollectionUtils.isEmpty(schemaMapping.getSkipPolicy().getSkipRowsWithFieldValues())) {
        return false;
    }

    Map<String, FieldSkipPolicy> fieldSkipPolicyMap = schemaMapping.getSkipPolicy().getSkipRowsWithFieldValues();
    List<FieldMapping> fieldMappings = schemaMapping.getFieldMappingList();

    // Build a map of field names to their indices
    Map<String, Integer> fieldNameToIndexMap = new HashMap<>();
    for (int i = 0; i < fieldMappings.size(); i++) {
        fieldNameToIndexMap.put(fieldMappings.get(i).getName(), i);
    }

    // Only process fields involved in skip conditions
    for (Map.Entry<String, FieldSkipPolicy> entry : fieldSkipPolicyMap.entrySet()) {
        String fieldName = entry.getKey();
        FieldSkipPolicy fieldSkipPolicy = entry.getValue();

        Integer index = fieldNameToIndexMap.get(fieldName);
        if (index == null || index >= tokens.length) {
            continue; // Field not present or index out of bounds, skip
        }

        String fieldValue = tokens[index].trim();
        if (conditionMatchesForField(fieldSkipPolicy, fieldValue)) {
            return true; // Skip this line
        }
    }

    return false; // Do not skip
}








public GenericData.Record createAvroRecordFromPayload(String payload, FileUploadRequest fileUploadRequest, Schema avroSchema) {
    SchemaMapping schemaMapping = getAndValidateSchemaMapping(fileUploadRequest.getSourceSchemaName());

    String[] tokens = payload.split(Pattern.quote(schemaMapping.getDelimiter().getSymbol()));

    // Trim tokens to remove extra whitespace
    for (int i = 0; i < tokens.length; i++) {
        tokens[i] = tokens[i].trim();
    }

    // Check if the row should be skipped
    if (filteringService.shouldSkipForDelimitedLine(fileUploadRequest.getSourceSchemaName(), tokens)) {
        return null; // Skip this record
    }

    // Proceed to write the record
    return writeRecord(avroSchema, schemaMapping, tokens);
}











GenericData.Record writeRecord(Schema schema, SchemaMapping schemaMapping, String[] tokens) {
    GenericData.Record avroRecord = new GenericData.Record(schema);
    List<FieldMapping> fieldMappings = schemaMapping.getFieldMappingList();

    int tokenIndex = 0;
    for (FieldMapping fieldMapping : fieldMappings) {
        String currentValue = tokenIndex >= tokens.length ? "" : tokens[tokenIndex];
        tokenIndex++;

        // Check if we should include this field in the Avro record
        if (!filteringService.shouldIncludeField(fieldMapping.getName(), schemaMapping)) {
            continue; // Skip adding this field to the Avro record
        }

        // Map the value to the Avro record
        avroRecord.put(fieldMapping.getName(), convertToAvroValue(schema, fieldMapping, currentValue));
    }

    return avroRecord;
}










boolean conditionMatchesForField(FieldSkipPolicy fieldSkipPolicy, String fieldValue) {
    if (fieldSkipPolicy == null || CollectionUtils.isEmpty(fieldSkipPolicy.getValues())) {
        return false;
    }

    String condition = fieldSkipPolicy.getCondition();
    List<String> values = fieldSkipPolicy.getValues();

    if ("NOT".equalsIgnoreCase(condition)) {
        return !values.contains(fieldValue);
    } else if ("STARTS WITH".equalsIgnoreCase(condition)) {
        return values.stream().anyMatch(fieldValue::startsWith);
    }

    // Default condition is EQUALS
    return values.contains(fieldValue);
}