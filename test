import com.datastax.oss.driver.api.core.CqlSession;
import com.datastax.oss.driver.api.core.cql.AsyncResultSet;
import com.datastax.oss.driver.api.core.cql.BoundStatement;
import com.datastax.oss.driver.api.core.cql.PreparedStatement;
import com.datastax.oss.driver.api.core.cql.SimpleStatement;
import com.schwab.cdt.spos.source.config.cassandra.CassandraConfig;
import com.schwab.cdt.spos.source.exception.UnableToWriteToCassandraException;
import com.schwab.cdt.spos.source.job.aggregate.AggregateFactory;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.springframework.batch.item.Chunk;

import java.math.BigDecimal;
import java.math.BigInteger;
import java.time.Instant;
import java.util.Arrays;
import java.util.Collections;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.CompletionStage;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.*;

class CassandraItemWriterTest {

    @Mock
    private CqlSession mockSession;

    @Mock
    private CassandraConfig mockCassandraConfig;

    @Mock
    private PreparedStatement mockPreparedStatement;

    @Mock
    private BoundStatement mockBoundStatement;

    private CassandraItemWriter cassandraItemWriter;

    @BeforeEach
    void setUp() {
        MockitoAnnotations.openMocks(this);
        when(mockCassandraConfig.maxConcurrentWriteRequests()).thenReturn(100);
        cassandraItemWriter = new CassandraItemWriter(mockSession, mockCassandraConfig);
    }

    @Test
    void testWriteSuccess() {
        AggregateFactory.Aggregate mockAggregate = createMockAggregate();
        Chunk<AggregateFactory.Aggregate> chunk = new Chunk<>(Collections.singletonList(mockAggregate));

        when(mockSession.prepare(any(SimpleStatement.class))).thenReturn(mockPreparedStatement);
        when(mockPreparedStatement.bind()).thenReturn(mockBoundStatement);
        setupBoundStatementMock();

        // Mock the CompletionStage and its behavior
        CompletableFuture<AsyncResultSet> mockCompletionStage = CompletableFuture.completedFuture(mock(AsyncResultSet.class));
        when(mockSession.executeAsync(any(BoundStatement.class))).thenReturn(mockCompletionStage);

        doAnswer(invocation -> {
            Object[] args = invocation.getArguments();
            ((BiConsumer<AsyncResultSet, Throwable>) args[0]).accept(mock(AsyncResultSet.class), null);
            return null;
        }).when(mockCompletionStage).whenComplete(any(BiConsumer.class));

        assertDoesNotThrow(() -> cassandraItemWriter.write(chunk));

        verify(mockSession, times(1)).executeAsync(any(BoundStatement.class));
    }

    @Test
    void testWriteFailure() {
        AggregateFactory.Aggregate mockAggregate = createMockAggregate();
        Chunk<AggregateFactory.Aggregate> chunk = new Chunk<>(Collections.singletonList(mockAggregate));

        when(mockSession.prepare(any(SimpleStatement.class))).thenReturn(mockPreparedStatement);
        when(mockPreparedStatement.bind()).thenReturn(mockBoundStatement);
        setupBoundStatementMock();

        // Simulate an exception during async execution
        CompletableFuture<AsyncResultSet> mockCompletionStage = new CompletableFuture<>();
        when(mockSession.executeAsync(any(BoundStatement.class))).thenReturn(mockCompletionStage);

        doAnswer(invocation -> {
            Object[] args = invocation.getArguments();
            ((BiConsumer<AsyncResultSet, Throwable>) args[0]).accept(null, new RuntimeException("Simulated Exception"));
            return null;
        }).when(mockCompletionStage).whenComplete(any(BiConsumer.class));

        assertThrows(UnableToWriteToCassandraException.class, () -> cassandraItemWriter.write(chunk));
    }

    private AggregateFactory.Aggregate createMockAggregate() {
        AggregateFactory.Columns column1 = new AggregateFactory.Columns("column1", new AggregateFactory.Metadata(new BigInteger("12345"), "bigint", "source1", null, null));
        AggregateFactory.Columns column2 = new AggregateFactory.Columns("column2", new AggregateFactory.Metadata(new BigDecimal("123.45"), "decimal", "source2", null, 2));
        AggregateFactory.Table table = new AggregateFactory.Table("test_table", Arrays.asList(column1, column2));

        return new AggregateFactory.Aggregate("testAggregate", new AggregateFactory.SourceSchema("testSchema"), table, "testSql");
    }

    private void setupBoundStatementMock() {
        when(mockBoundStatement.setBigDecimal(anyString(), any(BigDecimal.class))).thenReturn(mockBoundStatement);
        when(mockBoundStatement.setBigInteger(anyString(), any(BigInteger.class))).thenReturn(mockBoundStatement);
        when(mockBoundStatement.setInstant(anyString(), any(Instant.class))).thenReturn(mockBoundStatement);
        when(mockBoundStatement.setString(anyString(), anyString())).thenReturn(mockBoundStatement);
    }
}









package com.schwab.cdt.spos.source.job;

import com.schwab.cdt.spos.source.logger.LogRecordCreator;
import com.schwab.pce.common.logging.eli.enums.ServiceCallType;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.springframework.boot.SpringApplication;
import org.springframework.context.ApplicationContext;
import org.springframework.batch.core.BatchStatus;
import org.springframework.batch.core.JobExecution;
import org.springframework.batch.core.StepExecution;
import org.springframework.batch.core.JobInstance;
import org.springframework.batch.core.ExitStatus;

import java.time.LocalDateTime;
import java.util.Date;
import java.util.HashSet;
import java.util.Set;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.mockito.Mockito.*;

class DataIngestionJobListenerTest {

    @Mock
    private LogRecordCreator logRecordCreator;

    @Mock
    private ApplicationContext applicationContext;

    private DataIngestionJobListener dataIngestionJobListener;

    @BeforeEach
    void setUp() {
        MockitoAnnotations.openMocks(this);
        dataIngestionJobListener = new DataIngestionJobListener(logRecordCreator, applicationContext);
    }

    @Test
    void beforeJob_logsInboundMessage() {
        JobExecution jobExecution = mock(JobExecution.class);
        JobInstance jobInstance = mock(JobInstance.class);
        when(jobExecution.getJobInstance()).thenReturn(jobInstance);
        when(jobInstance.getJobName()).thenReturn("testJob");
        when(jobExecution.getStartTime()).thenReturn(new Date());

        dataIngestionJobListener.beforeJob(jobExecution);

        verify(logRecordCreator, times(1)).toInbound(
            eq("Job has started with id: " + jobExecution.getJobId()),
            eq("ControlM Pcf Task"),
            eq(jobExecution.getStartTime()),
            anyMap(),
            isNull(),
            eq(ServiceCallType.RPC),
            isNull(),
            isNull(),
            isNull(),
            isNull()
        );
    }

    @Test
    void afterJob_logsOutboundMessage_andExitsApplicationOnFailure() {
        JobExecution jobExecution = mock(JobExecution.class);
        StepExecution stepExecution = mock(StepExecution.class);
        Set<StepExecution> stepExecutions = new HashSet<>();
        stepExecutions.add(stepExecution);

        when(jobExecution.getStepExecutions()).thenReturn(stepExecutions);
        when(jobExecution.getStatus()).thenReturn(BatchStatus.FAILED);
        when(jobExecution.getStartTime()).thenReturn(new Date());
        when(jobExecution.getEndTime()).thenReturn(new Date());

        dataIngestionJobListener.afterJob(jobExecution);

        verify(logRecordCreator, times(1)).toOutBound(
            eq("Job has finished with exit status: " + jobExecution.getExitStatus().getExitCode() +
                " and message: " + jobExecution.getExitStatus().getExitDescription()),
            eq("ControlM Pcf Task"),
            eq(jobExecution.getStartTime()),
            anyMap(),
            isNull(),
            eq(ServiceCallType.RPC),
            isNull(),
            isNull(),
            isNull(),
            isNull()
        );

        verify(applicationContext, times(1)).close();
    }

    @Test
    void afterJob_logsOutboundMessage_andExitsApplicationOnSuccess() {
        JobExecution jobExecution = mock(JobExecution.class);
        StepExecution stepExecution = mock(StepExecution.class);
        Set<StepExecution> stepExecutions = new HashSet<>();
        stepExecutions.add(stepExecution);

        when(jobExecution.getStepExecutions()).thenReturn(stepExecutions);
        when(jobExecution.getStatus()).thenReturn(BatchStatus.COMPLETED);
        when(jobExecution.getStartTime()).thenReturn(new Date());
        when(jobExecution.getEndTime()).thenReturn(new Date());

        dataIngestionJobListener.afterJob(jobExecution);

        verify(logRecordCreator, times(1)).toOutBound(
            eq("Job has finished with exit status: " + jobExecution.getExitStatus().getExitCode() +
                " and message: " + jobExecution.getExitStatus().getExitDescription()),
            eq("ControlM Pcf Task"),
            eq(jobExecution.getStartTime()),
            anyMap(),
            isNull(),
            eq(ServiceCallType.RPC),
            isNull(),
            isNull(),
            isNull(),
            isNull()
        );

        verify(applicationContext, times(1)).close();
    }
}
